// Code generated by mockery v2.40.2. DO NOT EDIT.

package crudmocks

import (
	context "context"

	dbsql "github.com/hyperledger/firefly-common/pkg/dbsql"
	ffapi "github.com/hyperledger/firefly-common/pkg/ffapi"

	mock "github.com/stretchr/testify/mock"

	squirrel "github.com/Masterminds/squirrel"
)

// CRUD is an autogenerated mock type for the CRUD type
type CRUD[T dbsql.Resource] struct {
	mock.Mock
}

// Count provides a mock function with given fields: ctx, filter
func (_m *CRUD[T]) Count(ctx context.Context, filter ffapi.Filter) (int64, error) {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ffapi.Filter) (int64, error)); ok {
		return rf(ctx, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ffapi.Filter) int64); ok {
		r0 = rf(ctx, filter)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, ffapi.Filter) error); ok {
		r1 = rf(ctx, filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Delete provides a mock function with given fields: ctx, id, hooks
func (_m *CRUD[T]) Delete(ctx context.Context, id string, hooks ...dbsql.PostCompletionHook) error {
	_va := make([]interface{}, len(hooks))
	for _i := range hooks {
		_va[_i] = hooks[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...dbsql.PostCompletionHook) error); ok {
		r0 = rf(ctx, id, hooks...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteMany provides a mock function with given fields: ctx, filter, hooks
func (_m *CRUD[T]) DeleteMany(ctx context.Context, filter ffapi.Filter, hooks ...dbsql.PostCompletionHook) error {
	_va := make([]interface{}, len(hooks))
	for _i := range hooks {
		_va[_i] = hooks[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, filter)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMany")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, ffapi.Filter, ...dbsql.PostCompletionHook) error); ok {
		r0 = rf(ctx, filter, hooks...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetByID provides a mock function with given fields: ctx, id, getOpts
func (_m *CRUD[T]) GetByID(ctx context.Context, id string, getOpts ...dbsql.GetOption) (T, error) {
	_va := make([]interface{}, len(getOpts))
	for _i := range getOpts {
		_va[_i] = getOpts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetByID")
	}

	var r0 T
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...dbsql.GetOption) (T, error)); ok {
		return rf(ctx, id, getOpts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ...dbsql.GetOption) T); ok {
		r0 = rf(ctx, id, getOpts...)
	} else {
		r0 = ret.Get(0).(T)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ...dbsql.GetOption) error); ok {
		r1 = rf(ctx, id, getOpts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByName provides a mock function with given fields: ctx, name, getOpts
func (_m *CRUD[T]) GetByName(ctx context.Context, name string, getOpts ...dbsql.GetOption) (T, error) {
	_va := make([]interface{}, len(getOpts))
	for _i := range getOpts {
		_va[_i] = getOpts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetByName")
	}

	var r0 T
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...dbsql.GetOption) (T, error)); ok {
		return rf(ctx, name, getOpts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ...dbsql.GetOption) T); ok {
		r0 = rf(ctx, name, getOpts...)
	} else {
		r0 = ret.Get(0).(T)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ...dbsql.GetOption) error); ok {
		r1 = rf(ctx, name, getOpts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByUUIDOrName provides a mock function with given fields: ctx, uuidOrName, getOpts
func (_m *CRUD[T]) GetByUUIDOrName(ctx context.Context, uuidOrName string, getOpts ...dbsql.GetOption) (T, error) {
	_va := make([]interface{}, len(getOpts))
	for _i := range getOpts {
		_va[_i] = getOpts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, uuidOrName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetByUUIDOrName")
	}

	var r0 T
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...dbsql.GetOption) (T, error)); ok {
		return rf(ctx, uuidOrName, getOpts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ...dbsql.GetOption) T); ok {
		r0 = rf(ctx, uuidOrName, getOpts...)
	} else {
		r0 = ret.Get(0).(T)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ...dbsql.GetOption) error); ok {
		r1 = rf(ctx, uuidOrName, getOpts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFirst provides a mock function with given fields: ctx, filter, getOpts
func (_m *CRUD[T]) GetFirst(ctx context.Context, filter ffapi.Filter, getOpts ...dbsql.GetOption) (T, error) {
	_va := make([]interface{}, len(getOpts))
	for _i := range getOpts {
		_va[_i] = getOpts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, filter)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFirst")
	}

	var r0 T
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ffapi.Filter, ...dbsql.GetOption) (T, error)); ok {
		return rf(ctx, filter, getOpts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ffapi.Filter, ...dbsql.GetOption) T); ok {
		r0 = rf(ctx, filter, getOpts...)
	} else {
		r0 = ret.Get(0).(T)
	}

	if rf, ok := ret.Get(1).(func(context.Context, ffapi.Filter, ...dbsql.GetOption) error); ok {
		r1 = rf(ctx, filter, getOpts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMany provides a mock function with given fields: ctx, filter
func (_m *CRUD[T]) GetMany(ctx context.Context, filter ffapi.Filter) ([]T, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetMany")
	}

	var r0 []T
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, ffapi.Filter) ([]T, *ffapi.FilterResult, error)); ok {
		return rf(ctx, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ffapi.Filter) []T); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]T)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, ffapi.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetQueryFactory provides a mock function with given fields:
func (_m *CRUD[T]) GetQueryFactory() ffapi.QueryFactory {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetQueryFactory")
	}

	var r0 ffapi.QueryFactory
	if rf, ok := ret.Get(0).(func() ffapi.QueryFactory); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ffapi.QueryFactory)
		}
	}

	return r0
}

// GetSequenceForID provides a mock function with given fields: ctx, id
func (_m *CRUD[T]) GetSequenceForID(ctx context.Context, id string) (int64, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetSequenceForID")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (int64, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) int64); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Insert provides a mock function with given fields: ctx, inst, hooks
func (_m *CRUD[T]) Insert(ctx context.Context, inst T, hooks ...dbsql.PostCompletionHook) error {
	_va := make([]interface{}, len(hooks))
	for _i := range hooks {
		_va[_i] = hooks[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, inst)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Insert")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, T, ...dbsql.PostCompletionHook) error); ok {
		r0 = rf(ctx, inst, hooks...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertMany provides a mock function with given fields: ctx, instances, allowPartialSuccess, hooks
func (_m *CRUD[T]) InsertMany(ctx context.Context, instances []T, allowPartialSuccess bool, hooks ...dbsql.PostCompletionHook) error {
	_va := make([]interface{}, len(hooks))
	for _i := range hooks {
		_va[_i] = hooks[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, instances, allowPartialSuccess)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InsertMany")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []T, bool, ...dbsql.PostCompletionHook) error); ok {
		r0 = rf(ctx, instances, allowPartialSuccess, hooks...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ModifyQuery provides a mock function with given fields: modifier
func (_m *CRUD[T]) ModifyQuery(modifier func(squirrel.SelectBuilder) (squirrel.SelectBuilder, error)) dbsql.CRUDQuery[T] {
	ret := _m.Called(modifier)

	if len(ret) == 0 {
		panic("no return value specified for ModifyQuery")
	}

	var r0 dbsql.CRUDQuery[T]
	if rf, ok := ret.Get(0).(func(func(squirrel.SelectBuilder) (squirrel.SelectBuilder, error)) dbsql.CRUDQuery[T]); ok {
		r0 = rf(modifier)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dbsql.CRUDQuery[T])
		}
	}

	return r0
}

// NewFilterBuilder provides a mock function with given fields: ctx
func (_m *CRUD[T]) NewFilterBuilder(ctx context.Context) ffapi.FilterBuilder {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for NewFilterBuilder")
	}

	var r0 ffapi.FilterBuilder
	if rf, ok := ret.Get(0).(func(context.Context) ffapi.FilterBuilder); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ffapi.FilterBuilder)
		}
	}

	return r0
}

// NewUpdateBuilder provides a mock function with given fields: ctx
func (_m *CRUD[T]) NewUpdateBuilder(ctx context.Context) ffapi.UpdateBuilder {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for NewUpdateBuilder")
	}

	var r0 ffapi.UpdateBuilder
	if rf, ok := ret.Get(0).(func(context.Context) ffapi.UpdateBuilder); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ffapi.UpdateBuilder)
		}
	}

	return r0
}

// Replace provides a mock function with given fields: ctx, inst, hooks
func (_m *CRUD[T]) Replace(ctx context.Context, inst T, hooks ...dbsql.PostCompletionHook) error {
	_va := make([]interface{}, len(hooks))
	for _i := range hooks {
		_va[_i] = hooks[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, inst)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Replace")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, T, ...dbsql.PostCompletionHook) error); ok {
		r0 = rf(ctx, inst, hooks...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Scoped provides a mock function with given fields: scope
func (_m *CRUD[T]) Scoped(scope squirrel.Eq) dbsql.CRUD[T] {
	ret := _m.Called(scope)

	if len(ret) == 0 {
		panic("no return value specified for Scoped")
	}

	var r0 dbsql.CRUD[T]
	if rf, ok := ret.Get(0).(func(squirrel.Eq) dbsql.CRUD[T]); ok {
		r0 = rf(scope)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dbsql.CRUD[T])
		}
	}

	return r0
}

// TableAlias provides a mock function with given fields:
func (_m *CRUD[T]) TableAlias() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for TableAlias")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Update provides a mock function with given fields: ctx, id, update, hooks
func (_m *CRUD[T]) Update(ctx context.Context, id string, update ffapi.Update, hooks ...dbsql.PostCompletionHook) error {
	_va := make([]interface{}, len(hooks))
	for _i := range hooks {
		_va[_i] = hooks[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id, update)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Update, ...dbsql.PostCompletionHook) error); ok {
		r0 = rf(ctx, id, update, hooks...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateMany provides a mock function with given fields: ctx, filter, update, hooks
func (_m *CRUD[T]) UpdateMany(ctx context.Context, filter ffapi.Filter, update ffapi.Update, hooks ...dbsql.PostCompletionHook) error {
	_va := make([]interface{}, len(hooks))
	for _i := range hooks {
		_va[_i] = hooks[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, filter, update)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMany")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, ffapi.Filter, ffapi.Update, ...dbsql.PostCompletionHook) error); ok {
		r0 = rf(ctx, filter, update, hooks...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateSparse provides a mock function with given fields: ctx, sparseUpdate, hooks
func (_m *CRUD[T]) UpdateSparse(ctx context.Context, sparseUpdate T, hooks ...dbsql.PostCompletionHook) error {
	_va := make([]interface{}, len(hooks))
	for _i := range hooks {
		_va[_i] = hooks[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, sparseUpdate)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSparse")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, T, ...dbsql.PostCompletionHook) error); ok {
		r0 = rf(ctx, sparseUpdate, hooks...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Upsert provides a mock function with given fields: ctx, inst, optimization, hooks
func (_m *CRUD[T]) Upsert(ctx context.Context, inst T, optimization dbsql.UpsertOptimization, hooks ...dbsql.PostCompletionHook) (bool, error) {
	_va := make([]interface{}, len(hooks))
	for _i := range hooks {
		_va[_i] = hooks[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, inst, optimization)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Upsert")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, T, dbsql.UpsertOptimization, ...dbsql.PostCompletionHook) (bool, error)); ok {
		return rf(ctx, inst, optimization, hooks...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, T, dbsql.UpsertOptimization, ...dbsql.PostCompletionHook) bool); ok {
		r0 = rf(ctx, inst, optimization, hooks...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, T, dbsql.UpsertOptimization, ...dbsql.PostCompletionHook) error); ok {
		r1 = rf(ctx, inst, optimization, hooks...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Validate provides a mock function with given fields:
func (_m *CRUD[T]) Validate() {
	_m.Called()
}

// NewCRUD creates a new instance of CRUD. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCRUD[T dbsql.Resource](t interface {
	mock.TestingT
	Cleanup(func())
}) *CRUD[T] {
	mock := &CRUD[T]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
